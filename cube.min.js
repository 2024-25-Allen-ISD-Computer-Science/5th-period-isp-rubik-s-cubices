(function() {
  // Centers
  var B, BL, BR, Cube, D, DB, DBL, DF, DFR, DL, DLF, DR, DRB, F, FL, FR, L, R, U, UB, UBR, UF, UFL, UL, ULB, UR, URF, centerColor, centerFacelet, cornerColor, cornerFacelet, edgeColor, edgeFacelet;

  [U, R, F, D, L, B] = [0, 1, 2, 3, 4, 5];

  // Corners
  [URF, UFL, ULB, UBR, DFR, DLF, DBL, DRB] = [0, 1, 2, 3, 4, 5, 6, 7];

  // Edges
  [UR, UF, UL, UB, DR, DF, DL, DB, FR, FL, BL, BR] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];

  [centerFacelet, cornerFacelet, edgeFacelet] = (function() {
    var _B, _D, _F, _L, _R, _U;
    _U = function(x) { return x - 1; };
    _R = function(x) { return _U(9) + x; };
    _F = function(x) { return _R(9) + x; };
    _D = function(x) { return _F(9) + x; };
    _L = function(x) { return _D(9) + x; };
    _B = function(x) { return _L(9) + x; };
    return [
      // Centers
      [4, 13, 22, 31, 40, 49],
      // Corners
      [
        [_U(9), _R(1), _F(3)],
        [_U(7), _F(1), _L(3)],
        [_U(1), _L(1), _B(3)],
        [_U(3), _B(1), _R(3)],
        [_D(3), _F(9), _R(7)],
        [_D(1), _L(9), _F(7)],
        [_D(7), _B(9), _L(7)],
        [_D(9), _R(9), _B(7)]
      ],
      // Edges
      [
        [_U(6), _R(2)],
        [_U(8), _F(2)],
        [_U(4), _L(2)],
        [_U(2), _B(2)],
        [_D(6), _R(8)],
        [_D(2), _F(8)],
        [_D(4), _L(8)],
        [_D(8), _B(8)],
        [_F(6), _R(4)],
        [_F(4), _L(6)],
        [_B(6), _L(4)],
        [_B(4), _R(6)]
      ]
    ];
  })();

  centerColor = ['U', 'R', 'F', 'D', 'L', 'B'];
  cornerColor = [
    ['U', 'R', 'F'], ['U', 'F', 'L'], ['U', 'L', 'B'], ['U', 'B', 'R'],
    ['D', 'F', 'R'], ['D', 'L', 'F'], ['D', 'B', 'L'], ['D', 'R', 'B']
  ];
  edgeColor = [
    ['U', 'R'], ['U', 'F'], ['U', 'L'], ['U', 'B'],
    ['D', 'R'], ['D', 'F'], ['D', 'L'], ['D', 'B'],
    ['F', 'R'], ['F', 'L'], ['B', 'L'], ['B', 'R']
  ];

  Cube = (function() {
    var faceNames, faceNums, parseAlg;

    class Cube {
      constructor(other) {
        var x;
        if (other != null) {
          this.init(other);
        } else {
          this.identity();
        }
        // For moves to avoid allocating new objects each time
        this.newCenter = Array(6).fill(0);
        this.newCp = Array(8).fill(0);
        this.newEp = Array(12).fill(0);
        this.newCo = Array(8).fill(0);
        this.newEo = Array(12).fill(0);
      }

      init(state) {
        this.center = state.center.slice(0);
        this.co = state.co.slice(0);
        this.ep = state.ep.slice(0);
        this.cp = state.cp.slice(0);
        this.eo = state.eo.slice(0);
      }

      identity() {
        var x;
        this.center = [0, 1, 2, 3, 4, 5];
        this.cp = [0, 1, 2, 3, 4, 5, 6, 7];
        this.co = Array(8).fill(0);
        this.ep = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
        this.eo = Array(12).fill(0);
      }

      toJSON() {
        return {
          center: this.center,
          cp: this.cp,
          co: this.co,
          ep: this.ep,
          eo: this.eo
        };
      }

      asString() {
        var result = Array(54).fill('');
        for (var i = 0; i <= 5; i++) {
          result[9 * i + 4] = centerColor[this.center[i]];
        }
        for (var i = 0; i <= 7; i++) {
          var corner = this.cp[i];
          var ori = this.co[i];
          for (var n = 0; n <= 2; n++) {
            result[cornerFacelet[i][(n + ori) % 3]] = cornerColor[corner][n];
          }
        }
        for (var i = 0; i <= 11; i++) {
          var edge = this.ep[i];
          var ori = this.eo[i];
          for (var n = 0; n <= 1; n++) {
            result[edgeFacelet[i][(n + ori) % 2]] = edgeColor[edge][n];
          }
        }
        return result.join('');
      }

      static fromString(str) {
        var cube = new Cube();
        for (var i = 0; i <= 5; i++) {
          for (var j = 0; j <= 5; j++) {
            if (str[9 * i + 4] === centerColor[j]) {
              cube.center[i] = j;
            }
          }
        }
        for (var i = 0; i <= 7; i++) {
          var ori;
          for (ori = 0; ori <= 2; ori++) {
            if (['U', 'D'].includes(str[cornerFacelet[i][ori]])) {
              break;
            }
          }
          var col1 = str[cornerFacelet[i][(ori + 1) % 3]];
          var col2 = str[cornerFacelet[i][(ori + 2) % 3]];
          for (var j = 0; j <= 7; j++) {
            if (col1 === cornerColor[j][1] && col2 === cornerColor[j][2]) {
              cube.cp[i] = j;
              cube.co[i] = ori % 3;
            }
          }
        }
        for (var i = 0; i <= 11; i++) {
          for (var j = 0; j <= 11; j++) {
            if (str[edgeFacelet[i][0]] === edgeColor[j][0] && str[edgeFacelet[i][1]] === edgeColor[j][1]) {
              cube.ep[i] = j;
              cube.eo[i] = 0;
              break;
            }
            if (str[edgeFacelet[i][0]] === edgeColor[j][1] && str[edgeFacelet[i][1]] === edgeColor[j][0]) {
              cube.ep[i] = j;
              cube.eo[i] = 1;
              break;
            }
          }
        }
        return cube;
      }

      clone() {
        return new Cube(this.toJSON());
      }

      static random() {
        return new Cube().randomize();
      }

      isSolved() {
        var clone = this.clone();
        clone.move(clone.upright());
        for (var cent = 0; cent <= 5; cent++) {
          if (clone.center[cent] !== cent) return false;
        }
        for (var c = 0; c <= 7; c++) {
          if (clone.cp[c] !== c || clone.co[c] !== 0) return false;
        }
        for (var e = 0; e <= 11; e++) {
          if (clone.ep[e] !== e || clone.eo[e] !== 0) return false;
        }
        return true;
      }

      centerMultiply(other) {
        for (var to = 0; to <= 5; to++) {
          var from = other.center[to];
          this.newCenter[to] = this.center[from];
        }
        [this.center, this.newCenter] = [this.newCenter, this.center];
        return this;
      }

      cornerMultiply(other) {
        for (var to = 0; to <= 7; to++) {
          var from = other.cp[to];
          this.newCp[to] = this.cp[from];
          this.newCo[to] = (this.co[from] + other.co[to]) % 3;
        }
        [this.cp, this.newCp] = [this.newCp, this.cp];
        [this.co, this.newCo] = [this.newCo, this.co];
        return this;
      }

      edgeMultiply(other) {
        for (var to = 0; to <= 11; to++) {
          var from = other.ep[to];
          this.newEp[to] = this.ep[from];
          this.newEo[to] = (this.eo[from] + other.eo[to]) % 2;
        }
        [this.ep, this.newEp] = [this.newEp, this.ep];
        [this.eo, this.newEo] = [this.newEo, this.eo];
        return this;
      }

      multiply(other) {
        this.centerMultiply(other);
        this.cornerMultiply(other);
        this.edgeMultiply(other);
        return this;
      }

      move(arg) {
        var moves = parseAlg(arg);
        for (var move of moves) {
          var face = Math.floor(move / 3);
          var power = move % 3;
          for (var x = 0; x <= power; x++) {
            this.multiply(Cube.moves[face]);
          }
        }
        return this;
      }

      upright() {
        var clone = this.clone();
        var result = [];
        var i;
        for (i = 0; i <= 5; i++) {
          if (clone.center[i] === F) break;
        }
        switch (i) {
          case D: result.push("x"); break;
          case U: result.push("x'"); break;
          case B: result.push("x2"); break;
          case R: result.push("y"); break;
          case L: result.push("y'");
        }
        if (result.length) {
          clone.move(result[0]);
        }
        var j;
        for (j = 0; j <= 5; j++) {
          if (clone.center[j] === U) break;
        }
        switch (j) {
          case L: result.push("z"); break;
          case R: result.push("z'"); break;
          case D: result.push("z2");
        }
        return result.join(' ');
      }

      static inverse(arg) {
        var result = parseAlg(arg).map(move => {
          var face = Math.floor(move / 3);
          var power = move % 3;
          return face * 3 + (-(power - 1) + 1);
        }).reverse();
        if (typeof arg === 'string') {
          var str = '';
          for (var move of result) {
            var face = Math.floor(move / 3);
            var power = move % 3;
            str += faceNames[face];
            if (power === 1) str += '2';
            else if (power === 2) str += "'";
            str += ' ';
          }
          return str.trim();
        } else if (Array.isArray(arg)) {
          return result;
        } else {
          return result[0];
        }
      }

      randomize() {
        var randint = (min, max) => min + Math.floor(Math.random() * (max - min + 1));
        var shuffle = array => {
          for (var i = array.length - 1; i > 0; i--) {
            var j = randint(0, i);
            [array[i], array[j]] = [array[j], array[i]];
          }
        };
        var getNumSwaps = arr => {
          var numSwaps = 0;
          var seen = Array(arr.length).fill(false);
          while (true) {
            var cur = -1;
            for (var i = 0; i < arr.length; i++) {
              if (!seen[i]) {
                cur = i;
                break;
              }
            }
            if (cur === -1) break;
            var cycleLength = 0;
            while (!seen[cur]) {
              seen[cur] = true;
              cycleLength++;
              cur = arr[cur];
            }
            numSwaps += cycleLength + 1;
          }
          return numSwaps;
        };
        var arePermutationsValid = (cp, ep) => (getNumSwaps(ep) + getNumSwaps(cp)) % 2 === 0;
        var generateValidRandomPermutation = (cp, ep) => {
          do {
            shuffle(ep);
            shuffle(cp);
          } while (!arePermutationsValid(cp, ep));
        };
        var randomizeOrientation = (arr, numOrientations) => {
          var ori = 0;
          for (var i = 0; i < arr.length - 1; i++) {
            ori += (arr[i] = randint(0, numOrientations - 1));
          }
          arr[arr.length - 1] = (numOrientations - (ori % numOrientations)) % numOrientations;
        };
        var isOrientationValid = (arr, numOrientations) => arr.reduce((a, b) => a + b, 0) % numOrientations === 0;
        var generateValidRandomOrientation = (co, eo) => {
          do {
            randomizeOrientation(co, 3);
          } while (!isOrientationValid(co, 3));
          do {
            randomizeOrientation(eo, 2);
          } while (!isOrientationValid(eo, 2));
        };
        generateValidRandomPermutation(this.cp, this.ep);
        generateValidRandomOrientation(this.co, this.eo);
        return this;
      }
    }

    Cube.moves = [
      // U
      {
        center: [0, 1, 2, 3, 4, 5],
        cp: [UBR, URF, UFL, ULB, DFR, DLF, DBL, DRB],
        co: [0, 0, 0, 0, 0, 0, 0, 0],
        ep: [UB, UR, UF, UL, DR, DF, DL, DB, FR, FL, BL, BR],
        eo: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      // R
      {
        center: [0, 1, 2, 3, 4, 5],
        cp: [DFR, UFL, ULB, URF, DRB, DLF, DBL, UBR],
        co: [2, 0, 0, 1, 1, 0, 0, 2],
        ep: [FR, UF, UL, UB, BR, DF, DL, DB, DR, FL, BL, UR],
        eo: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      // F
      {
        center: [0, 1, 2, 3, 4, 5],
        cp: [UFL, DLF, ULB, UBR, URF, DFR, DBL, DRB],
        co: [1, 2, 0, 0, 2, 1, 0, 0],
        ep: [UR, FL, UL, UB, DR, FR, DL, DB, UF, DF, BL, BR],
        eo: [0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0]
      },
      // D
      {
        center: [0, 1, 2, 3, 4, 5],
        cp: [URF, UFL, ULB, UBR, DLF, DBL, DRB, DFR],
        co: [0, 0, 0, 0, 0, 0, 0, 0],
        ep: [UR, UF, UL, UB, DF, DL, DB, DR, FR, FL, BL, BR],
        eo: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      // L
      {
        center: [0, 1, 2, 3, 4, 5],
        cp: [URF, ULB, DBL, UBR, DFR, UFL, DLF, DRB],
        co: [0, 1, 2, 0, 0, 2, 1, 0],
        ep: [UR, UF, BL, UB, DR, DF, FL, DB, FR, UL, DL, BR],
        eo: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      // B
      {
        center: [0, 1, 2, 3, 4, 5],
        cp: [URF, UFL, UBR, DRB, DFR, DLF, ULB, DBL],
        co: [0, 0, 1, 2, 0, 0, 2, 1],
        ep: [UR, UF, UL, BR, DR, DF, DL, BL, FR, FL, UB, DB],
        eo: [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1]
      },
      // E
      {
        center: [U, F, L, D, B, R],
        cp: [URF, UFL, ULB, UBR, DFR, DLF, DBL, DRB],
        co: [0, 0, 0, 0, 0, 0, 0, 0],
        ep: [UR, UF, UL, UB, DR, DF, DL, DB, FL, BL, BR, FR],
        eo: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
      },
      // M
      {
        center: [B, R, U, F, L, D],
        cp: [URF, UFL, ULB, UBR, DFR, DLF, DBL, DRB],
        co: [0, 0, 0, 0, 0, 0, 0, 0],
        ep: [UR, UB, UL, DB, DR, UF, DL, DF, FR, FL, BL, BR],
        eo: [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0]
      },
      // S
      {
        center: [L, U, F, R, D, B],
        cp: [URF, UFL, ULB, UBR, DFR, DLF, DBL, DRB],
        co: [0, 0, 0, 0, 0, 0, 0, 0],
        ep: [UL, UF, DL, UB, UR, DF, DR, DB, FR, FL, BL, BR],
        eo: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
      }
    ];

    faceNums = {
      U: 0, R: 1, F: 2, D: 3, L: 4, B: 5, E: 6, M: 7, S: 8,
      x: 9, y: 10, z: 11, u: 12, r: 13, f: 14, d: 15, l: 16, b: 17
    };

    faceNames = {
      0: 'U', 1: 'R', 2: 'F', 3: 'D', 4: 'L', 5: 'B', 6: 'E', 7: 'M', 8: 'S',
      9: 'x', 10: 'y', 11: 'z', 12: 'u', 13: 'r', 14: 'f', 15: 'd', 16: 'l', 17: 'b'
    };

    parseAlg = function(arg) {
      if (typeof arg === 'string') {
        var parts = arg.split(/\s+/).filter(part => part.length > 0);
        var results = [];
        for (var part of parts) {
          if (part.length > 2) throw new Error(`Invalid move: ${part}`);
          var move = faceNums[part[0]];
          if (move === undefined) throw new Error(`Invalid move: ${part}`);
          var power = part.length === 1 ? 0 : (part[1] === '2' ? 1 : (part[1] === "'" ? 2 : -1));
          if (power === -1) throw new Error(`Invalid move: ${part}`);
          results.push(move * 3 + power);
        }
        return results;
      } else if (Array.isArray(arg)) {
        return arg;
      } else {
        return [arg];
      }
    };

    // Additional moves
    Cube.moves.push(new Cube().move("R M' L'").toJSON()); // x
    Cube.moves.push(new Cube().move("U E' D'").toJSON()); // y
    Cube.moves.push(new Cube().move("F S B'").toJSON()); // z
    Cube.moves.push(new Cube().move("U E'").toJSON()); // u
    Cube.moves.push(new Cube().move("R M'").toJSON()); // r
    Cube.moves.push(new Cube().move("F S").toJSON()); // f
    Cube.moves.push(new Cube().move("D E").toJSON()); // d
    Cube.moves.push(new Cube().move("L M").toJSON()); // l
    Cube.moves.push(new Cube().move("B S'").toJSON()); // b

    return Cube;
  }).call(this);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Cube;
  } else {
    this.Cube = Cube;
  }
}).call(this);
